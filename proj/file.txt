#include "globals.h"

//many functions taken from lab6 prework
int tst_bit(char *buf, int bit){
  int i, j;
  i = bit/8; j=bit%8;
  if (buf[i] & (1 << j))
     return 1;
  return 0;
}

int set_bit(char *buf, int bit){
  int i, j;
  i = bit/8; j=bit%8;
  buf[i] |= (1 << j);
}

int clr_bit(char *buf, int bit){
  int i, j;
  i = bit/8; j=bit%8;
  buf[i] &= ~(1 << j);
}

int decFreeInodes(int dev){
  char buf[BLKSIZE];

  // dec free inodes count in SUPER
  get_block(dev, 1, buf);
  sp = (SUPER *)buf;
  sp->s_free_inodes_count--;
  put_block(dev, 1, buf);

  // dec free inodes count in GD
  get_block(dev, 2, buf);
  gp = (GD *)buf;
  gp->bg_free_inodes_count--;
  put_block(dev, 2, buf);
}

int incFreeInodes(int dev){
  char buf[BLKSIZE];

  // inc free inodes count in SUPER
  get_block(dev, 1, buf);
  sp = (SUPER *)buf;
  sp->s_free_inodes_count++;
  put_block(dev, 1, buf);

  // inc free inodes count in GD
  get_block(dev, 2, buf);
  gp = (GD *)buf;
  gp->bg_free_inodes_count++;
  put_block(dev, 2, buf);
}

int decFreeBlocks(int dev){
  char buf[BLKSIZE];

  // dec free inodes count in SUPER
  get_block(dev, 1, buf);
  sp = (SUPER *)buf;
  sp->s_free_blocks_count--;
  put_block(dev, 1, buf);

  // dec free inodes count in GD
  get_block(dev, 2, buf);
  gp = (GD *)buf;
  gp->bg_free_blocks_count--;
  put_block(dev, 2, buf);
}

int incFreeBlocks(int dev){
  char buf[BLKSIZE];

  // inc free inodes count in SUPER
  get_block(dev, 1, buf);
  sp = (SUPER *)buf;
  sp->s_free_blocks_count++;
  put_block(dev, 1, buf);

  // inc free inodes count in GD
  get_block(dev, 2, buf);
  gp = (GD *)buf;
  gp->bg_free_blocks_count++;
  put_block(dev, 2, buf);
}

int ialloc(int dev){
  int  i;
  char buf[BLKSIZE];

  // read inode_bitmap block
  get_block(dev, imap, buf);

  for (i=0; i < ninodes; i++){
    if (tst_bit(buf, i)==0){
       set_bit(buf,i);
       decFreeInodes(dev);

       put_block(dev, imap, buf);

       return i+1;
    }
  }
  printf("Error in ialloc(): no more free inodes\n");
  return 0;
}

int balloc(int dev){
	int  i;
	char buf[BLKSIZE];

	// read block_bitmap block
	get_block(dev, bmap, buf);

	for (i=0; i < nblocks; i++){
		if (tst_bit(buf, i)==0){
		   set_bit(buf,i);
		   decFreeBlocks(dev);

		   put_block(dev, bmap, buf);

		   return i+1;
		}
	}
	printf("Error in balloc(): no more free inodes\n");
	return 0;
}

int idealloc(int dev, int ino){//assumes inode is empty as in all blocks deallocated in inode
	char buf[BLKSIZE];
	
	// read inode_bitmap block
	get_block(dev, imap, buf);
	clr_bit(buf,ino);
	incFreeInodes(dev);
	
	put_block(dev, imap, buf);
}

int bdealloc(int dev, int bno){//assumes block is empty as in all inodes deallocated in block
	char buf[BLKSIZE];

	// read block_bitmap block
	get_block(dev, bmap, buf);
	clr_bit(buf,bno);
	incFreeBlocks(dev);
	
	put_block(dev, bmap, buf);
}
#include "globals.h"

char buf[BLKSIZE];
MINODE *mip;
INODE *ip;

int chmod_file(int ino, char new_mode[]){
  //Child Inode
  mip = iget(dev, ino);
  ip = &(mip->INODE);

  //Parse Through Permission In Order To Write Correctly
  char *permission = "rwxrwxrwx";
  long int new_imode = strtol(new_mode, NULL, 8);
  ip->i_mode = (ip->i_mode & 0xF000) | new_imode;
  printf("New Permissions: ");
  for(int i = 0; i < 9; i++){
    if(ip->i_mode & (1 << (strlen(permission)-1-i))){
      putchar(permission[i]);
    }
    else{
      putchar('-');
    }
  }
  printf("\n");
  //Set As Dirty And Write Back
  mip->dirty = 1;
  iput(mip);
}

int my_chmod(char new_mode[]){
  //Create Temp To Tokenize Pathname
  char temp_pathname[64];
  strcpy(temp_pathname,pathname);
  char * chmod_parent = dirname(temp_pathname);
  char * chmod_child = basename(pathname);

  printf("PARENT: %s\tCHILD: %s\n\n\n\n",chmod_parent,chmod_child);
  //Get The Parent INODE
  int inom = getino(dev,chmod_parent);
  mip = iget(dev, inom);
  ip = &(mip->INODE);

  //Load The Data Block[0] Into chmod_buf
  char chmod_buf[BLKSIZE], temp[256];
  char *cp;
  get_block(dev, ip->i_block[0], chmod_buf);

  //Set Up cp and dp
  cp = chmod_buf;
  dp = (DIR *)chmod_buf;

  //Increment Through chmod_buf Looking for child(name)
  while(cp < chmod_buf+1024){
    strncpy(temp, dp->name, dp->name_len);
    temp[dp->name_len] = 0;
    if(strcmp(temp,chmod_child)==0){ //If Hit
      chmod_file(dp->inode, new_mode); 
    }
    //Increment
    cp += dp->rec_len;
    dp = (DIR *)cp;
    }
  //Set As Dirty And Write Back
  mip->dirty = 1;
  iput(mip);
}

MINODE *my_iget(int dev, int ino)
{
  int i;
  MINODE *mip;
  char buf[BLKSIZE];
  int blk, disp;
  INODE *ip;

  //Search MINODE[] For Entry
  for(i=0; i<NMINODE; i++){
    mip = &minode[i];
    if(mip->dev == dev && mip->ino == ino){
      mip->refCount++;
      printf("Found INODE: %d At MINODE: %d\n",ino,i);
      return mip;
    }
  }

  for (i=0; i<NMINODE; i++){
    mip = &minode[i];
    if (mip->refCount == 0){
      printf("Loaded INODE: %d Into MINODE: %d\n",ino,i);
      mip->refCount = 1;
      mip->dev = dev;
      mip->ino = ino;

      //Mailmans Alg.
      blk  = (ino-1)/8 + iblk;
      disp = (ino-1) % 8;

      //Get Block And Load Into Buf Then Set INODE Pointer Accordingly
      get_block(dev, blk, buf);
      ip = (INODE *)buf + disp;
      // copy INODE to mp->INODE
      mip->INODE = *ip;
      return mip;
    }
  }
  printf("Error MINODES[] Is Full\n");
  return 0;
}

my_iput(MINODE *mip)
{
  int i, block, offset;
  char buf[BLKSIZE];
  INODE *ip;

  if(mip==0){ //NULL Case
    return;
  }
  mip->refCount--;

  if(mip->refCount > 0){ //Being Referenced Case
    return;
  }
  if(!mip->dirty){ //Not Changed Case
    return;
  }

  /* write back */
  printf("my_iput ino: %d\n",mip->ino);

  //Mailmans Alg.
  block = ((mip->ino-1)/8)+iblk;
  offset = (mip->ino-1)%8;

  //Get Block Containing INODE
  get_block(mip->dev, block, buf);

  //Get The Actual INODE In Buf By Going To The Offest
  ip = (INODE *)buf + offset;
  *ip = mip->INODE;

  //Put Back
  put_block(mip->dev, block, buf);

}

int tokenize(char *pathname)
{
  char *s;
  printf("Tokenize Pathname:  %s\n", pathname);
  strcpy(gpath, pathname);
  n = 0;

  s = strtok(gpath, "/");

  while(s){
    name[n] = s;
    n++;
    s = strtok(0, "/");
  }
}

int my_search(MINODE *mip, char *name)
{
  int i;
  char *cp, c, sbuf[BLKSIZE];
  DIR *dp;
  INODE *ip;

  printf("my_search: Search For %s Inside MINODE[%d]\n", name,mip->ino);
  ip = &(mip->INODE);


  for(i=0; i<12; i++){ /* search direct blocks only */
    printf("my_search: i_block[%d]=%d\n",i, ip->i_block[i]);
    if(ip->i_block[i] == 0)
      return 0;

    //Get The i_block Load It Into sbuf For Parsing
    get_block(dev, ip->i_block[i], sbuf);
    dp = (DIR *)sbuf;
    cp = sbuf;
    printf("   i_number rec_len name_len    name\n");

    while(cp < sbuf + BLKSIZE){
      c = dp->name[dp->name_len];
      dp->name[dp->name_len] = 0;

      printf("%8d%8d%8u        %s\n",dp->inode, dp->rec_len, dp->name_len, dp->name);
      if(strcmp(dp->name, name)==0){
	printf("Found Name: %s At ino: %d\n", name, dp->inode);
	return(dp->inode);
      }
      //Increment
      dp->name[dp->name_len] = c;
      cp += dp->rec_len;
      dp = (DIR *)cp;
    }
  }
  return(0);
}

int my_getino(int dev, char *pathname)
{
  int i, ino, blk, disp;
  char buf[BLKSIZE];
  INODE *ip;
  MINODE *mip;

  printf("my_getino For Pathname: %s\n", pathname);
  if (strcmp(pathname, "/")==0){ //Just Root
    return 2;
  }
  if (pathname[0]=='/'){ //Absolute
    mip = my_iget(dev, 2);
  }
  else{ //Relative
    mip = my_iget(running->cwd->dev, running->cwd->ino);
  }
  strcpy(buf, pathname);
  tokenize(buf);

  for (i=0; i<n; i++){
    printf("my_getino name:%s\n",name[i]);

    ino = my_search(mip, name[i]);

    if(ino==0){
      my_iput(mip);
      printf("name %s does not exist\n", name[i]);
      return 0;
    }
    my_iput(mip);
    mip = my_iget(dev,ino);
  }
  my_iput(mip);
  return ino;
}
#include "globals.h"

//This File Will House Link and Unlink Functions

int my_link(char oldfile[], char newfile[]){
  //Input Structure: link oldFile newFile

  //Get INODE For oldfile
  int old_ino = getino(dev,oldfile);
  MINODE *old_ip = iget(dev,old_ino);

  if(old_ip->INODE.i_mode == 0x81A4){//Validate The oldfile INODE Is A File
    //Check NewFile Path (Minus BaseName)
    char * parent;
    char * child;
    char temp[64]; //Temp For Tokenizing
    strcpy(temp,newfile);
    parent = dirname(newfile);
    child = basename(temp);
    printf("Parent: %s Child: %s\n\n\n",parent,child);


    //Grab The Parent MINODE (The Parents dirname)
    int parent_ino = getino(dev,parent);
    MINODE *parent_ip = iget(dev,parent_ino);
    printf("Parent ino: %d\n",parent_ino);


    //Add Entry To New Dir
    if(parent_ip->INODE.i_mode == 0x41ED){ //Parent Is A Directory
      //Call my_link_creat to create the new file with the old inumber
      enter_name(parent_ip,old_ino,child);

      parent_ip->dirty = 1;
      parent_ip->INODE.i_atime = time(0L);
    }
    else{ //Parent Isn't A Dir
      printf("Parent Isn't A Directory\n");
      return -1;
    }
    //Mark As Dirty And Increase The Links For The Old File
    old_ip->dirty = 1;
    old_ip->INODE.i_links_count++;
    iput(parent_ip);
  }
  else{ //The oldFile Is Not A File
    printf("Input One Is Not A File\n");
  }

  //Write It Back To Disk
  iput(old_ip);
}



int my_unlink(char oldfile[]){

  //Get INODE For OldFile
  int old_ino = getino(dev,oldfile);
  MINODE *old_ip = iget(dev,old_ino);

  //Create Temp Char* For Parent And Child
  char temp[64];
  strcpy(temp,oldfile);
  char *parent = dirname(temp);
  char *child = basename(oldfile);

  //Validate Type
  if(old_ip->INODE.i_mode == 0x81A4){ //Check If oldfile Is File
    //Remove Links Count, Make It Dirty
    old_ip->INODE.i_links_count--;
    old_ip->dirty = 1;

    if(old_ip->INODE.i_links_count == 0){ //Must Remove Because Links = 0
      //Deallocate All Blocks
      truncate(old_ip);
      //Deallocate Inode Itself
      idealloc(dev, old_ip->ino);

    }
    //Remove The Name From Parent
    int parent_ino = getino(dev,parent);
    MINODE *parent_ip = iget(dev,parent_ino);
    rm_child(parent_ip,child);
    iput(parent_ip);
  }
  else{ //File Isnt File
    printf("Pathname Doesnt Lead To File\n");
    return -1;
  }

  //Write It Back To Disk
  iput(old_ip);
}

#include "globals.h"

char buf[BLKSIZE];


int ls_file(int ino){
  MINODE *mip = iget(dev, ino);
  INODE *ip = &(mip->INODE);
  char *Permission = "rwxrwxrwx";
  printf("Permissions: ");
  for(int i = 0; i < 9; i++){
    if(ip->i_mode & (1 << (strlen(Permission)-1-i))){
      putchar(Permission[i]);
    }
    else{
      putchar('-');
    }
  }
  printf("%07o ",ip->i_mode);
  printf("%d ",ip->i_uid);
  printf("%d ",ip->i_gid);
  printf("%d ",ip->i_atime);
  my_iput(mip);
}

int ls_dir(int ino){
  MINODE * mip = iget(dev, ino);
  INODE * ip = &(mip->INODE);

  char lsbuf[BLKSIZE], temp[256];
  char *cp;
  get_block(dev, ip->i_block[0], lsbuf);

  cp = lsbuf;
  dp = (DIR *)lsbuf;

  while(cp < lsbuf+1024){
    ls_file(dp->inode);
    strncpy(temp, dp->name, dp->name_len);
    temp[dp->name_len] = 0;
    printf("%s\n", temp);

    cp += dp->rec_len;
    dp = (DIR *)cp;

  }
  my_iput(mip);
}

int parse_path(char *path, char *name[256]){
  int nlen = 0;
  char * temp;
  temp = strtok(path, "/");
  name[nlen++]= temp;

  while(temp = strtok(0,"/")){//parses path into name array
    name[nlen++] = temp;
  }
  return nlen;
}

int list_file(char *path){
    int ino = 0;
    if(strlen(path)==0){
      ls_dir(running->cwd->ino);
    }
    else{
      ino = getino(dev, path);
      if( ino == 0){
        return 0;
      }
      ls_dir(ino);
    }
  return 0;
}

int change_dir(char *path){
  MINODE *tip;
  char *name[256];
  int nlen = 0;
  int cur = 0;
  char * temp;
  if(strcmp(path,"/")==0){
    tip = iget(dev,2);
    my_iput(running->cwd);
    running->cwd = tip;
    return 0;
  }
  else{
    if(path[0] == '/'){
      tip = iget(dev,2);
    }
    else{
      tip = running->cwd;
    }
  }
  temp = strtok(path, "/");
  name[nlen++]= temp;

  while(temp = strtok(0,"/")){//parses path into name array
    name[nlen++] = temp;
  }
  int ino = 0;


  //make sure path exists
  printf("Find path....\n");
  for(cur=0;cur<nlen;cur++){
    ino = search(&(tip->INODE),name[cur]);
    if(!ino){
      printf("Path not found at %s\n", name[cur]);
      my_iput(tip);
      return -1;
    }
    my_iput(tip);
    tip = iget(dev, ino);
    if ((tip->INODE.i_mode & 0xF000) != 0x4000){
      printf("ls failed: not a DIR\n");
      my_iput(tip);
      return -1;
    }
    printf("Found ino: %d\n", ino);
  }
  printf("OK\n");
  my_iput(running->cwd);
  running->cwd = tip;
}

int rpwd(INODE *ip){
  get_block(dev,ip->i_block[0], buf);

  //Load Buf
  char *cp = buf;
  dp = (DIR *)buf;

  char charArray[256];

  //Begin Move Process
  int temp = dp->inode;
  cp += dp->rec_len; //Moving To ..
  dp = (DIR *)cp;

  //Grab Parent
  MINODE *mip = iget(dev,dp->inode);
  ip = &(mip->INODE);
  //Grab Block
  get_block(dev,ip->i_block[0], buf);
  //Load Buf
  cp = buf;
  dp = (DIR *)buf;
  DIR *dp2;
  cp += dp->rec_len;
  dp2 = (DIR *)cp;
  DIR *dp3;
  dp3=dp2;
  while(temp != dp3->inode){
    cp += dp3->rec_len;
    dp3 = (DIR *)cp;
  }

  //Load Name Into charArray[] And Add NULL Char
  strcpy(charArray,dp3->name);
  charArray[dp3->name_len] = 0;

  //Begin Loop Process
  if(dp->inode == dp2->inode){ //Check . Against ..
    printf("/");
    if(strcmp(charArray,"..")==0){
      my_iput(mip);
      return 0;
    }
    printf("%s/",charArray);
    my_iput(mip);
    return 0;
  }
  else{
    rpwd(mip); //Otherwise Recursive Call Memory INODE Pointer
    printf("%s/",charArray);
    my_iput(mip);
  }
}

int pwd(INODE *ip){
  rpwd(ip);
}
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <libgen.h>
#include <sys/stat.h>
#include <ext2fs/ext2_fs.h>

#include "type.h"
#include "globals.h"
#include "getino.c"

MINODE minode[NMINODE];
MINODE *root;

PROC   proc[NPROC], *running;
MNTABLE mntable, *mntPtr;

SUPER *sp;
GD    *gp;
INODE *ip;
DIR *dp, *mdp;

int fd, dev;
int nblocks, ninodes, bmap, imap, iblk;
char line[128], cmd[32], pathname[64];

char tempPathName[64];
char gpath[128];   // hold tokenized strings
char *name[64];    // token string pointers
int  n;            // number of token strings

MINODE * iget(int dev, int ino)
{
  printf("iget(%d %d): ", dev, ino);
  return (MINODE *)my_iget(dev, ino);
}

int iput(MINODE *mip)
{
  printf("iput(%d %d)\n", mip->dev, mip->ino);
  return my_iput(mip);
}

int getino(int dev, char *pathname)
{
  return my_getino(dev, pathname);
}

#include "util.c"
#include "ls-cd-pwd.c"
#include "mkdir-creat.c"
#include "alloc-dealloc.c"
#include "rmdir.c"
#include "stat.c"
#include "chmod.c"
#include "link-unlink.c"
#include "symlink.c"
#include "touch.c"
#include "rm.c"
#include "open_close_lseek.c"
#include "read-cat.c"
#include "write-cp-mv.c"


int init()
{
  int i, j;
  MINODE *mip;
  PROC   *p;

  printf("init()\n");

  for (i=0; i<NMINODE; i++){
    mip = &minode[i];
    mip->dev = mip->ino = 0;
    mip->refCount = 0;
    mip->mounted = 0;
    mip->mptr = 0;
  }
  for (i=0; i<NPROC; i++){
    p = &proc[i];
    p->pid = i;
    p->uid = 0;
    p->cwd = 0;
    for (j=0; j<NFD; j++)
      p->fd[j] = 0;
  }
}

// load root INODE and set root pointer to it
int mount_root()
{
  printf("mount_root()\n");
  root = iget(dev, 2);
  root->mounted = 1;
  root->mptr = &mntable;

  mntPtr = &mntable;
  mntPtr->dev = dev;
  mntPtr->ninodes = ninodes;
  mntPtr->nblocks = nblocks;
  mntPtr->bmap = bmap;
  mntPtr->imap = imap;
  mntPtr->iblk = iblk;
  mntPtr->mntDirPtr = root;
  strcpy(mntPtr->devName, "mydisk");
  strcpy(mntPtr->mntName, "/");
}

char *disk = "mydisk";
main(int argc, char *argv[ ])
{
  int ino;
  char buf[BLKSIZE];

  if (argc > 1)
    disk = argv[1];

  printf("checking EXT2 FS ....");
  if ((fd = open(disk, O_RDWR)) < 0){
    printf("open %s failed\n", disk);  exit(1);
  }
  dev = fd;

  /********** read super block at 1024 ****************/
  get_block(dev, 1, buf);
  sp = (SUPER *)buf;

  /* verify it's an ext2 file system *****************/
  if (sp->s_magic != 0xEF53){
      printf("magic = %x is not an ext2 filesystem\n", sp->s_magic);
      exit(1);
  }
  printf("OK\n");
  ninodes = sp->s_inodes_count;
  nblocks = sp->s_blocks_count;

  get_block(dev, 2, buf);
  gp = (GD *)buf;

  bmap = gp->bg_block_bitmap;
  imap = gp->bg_inode_bitmap;
  iblk = gp->bg_inode_table;
  printf("bmp=%d imap=%d iblk = %d\n", bmap, imap, iblk);

  init();
  mount_root();
  printf("root refCount = %d\n", root->refCount);

  printf("creating P0 as running process\n");
  running = &proc[0];
  running->cwd = iget(dev, 2);
  printf("root refCount = %d\n", root->refCount);

  //printf("hit a key to continue : "); getchar();
  while(1){
    printf("Commands: [ls|cd|pwd|mkdir|creat|rmdir|rm|stat|chmod|link|unlink|touch|open|close|lseek|pfd|cp|mv|cat|quit]\n");
    printf("Input: ");
    fgets(line, 128, stdin);

    line[strlen(line)-1] = 0;

    if (line[0]==0)
      continue;
    pathname[0] = 0;
    char permissions[64];

    sscanf(line, "%s %s %s", cmd, pathname,tempPathName);
    printf("cmd=%s pathname=%s\n", cmd, pathname);


    if(strcmp(cmd,"chmod")==0){
      strcpy(permissions,pathname);
      strcpy(pathname,tempPathName);
      for(int k = 0; k < 64; k++){
	tempPathName[k] = 0;
	}
    }
    char oldfile[64];
    char newfile[64];
    if(strcmp(cmd,"link")==0){
      //Do This In Order To Reorder Arguments
      strcpy(oldfile,pathname);
      strcpy(newfile,tempPathName);
      my_link(oldfile, newfile);
    }
    if(strcmp(cmd,"unlink")==0){
      strcpy(oldfile,pathname); //Do This To Avoid Destorying The Global
      my_unlink(oldfile);
    }
    if (strcmp(cmd, "ls")==0){
      list_file(pathname);
    }
    if (strcmp(cmd, "cd")==0)
      change_dir(pathname);
    if (strcmp(cmd, "pwd")==0){
      pwd(running->cwd);
      printf("\n");
    }
    if (strcmp(cmd, "quit")==0)
       quit();
    if(strcmp(cmd, "mkdir")==0){
      make_dir();
    }
    if(strcmp(cmd, "creat")==0){
      creat_file();
    }
    if(strcmp(cmd, "rmdir")==0){
      rmdir();
    }
    if(strcmp(cmd, "stat")==0){
      get_block(dev,running->cwd->INODE.i_block[0], buf);
      char *cp = buf;
      dp = (DIR *)buf;
      my_stat(dp->inode);
    }
    if(strcmp(cmd, "chmod")==0){
      //Note: Need to do parent and child
      my_chmod(permissions);
    }
    if(strcmp(cmd, "touch")==0){
      my_touch();
    }
    if(strcmp(cmd, "symlink")==0){
      char temp[64];
      strcpy(temp,pathname);
      my_symlink(temp,tempPathName);
    }
    if(strcmp(cmd, "readlink")==0){
      printf("%s\n",my_readlink());
    }
    if(strcmp(cmd, "rm")==0){
      my_rm();
    }
    if(strcmp(cmd,"open")==0){
      int mode = atoi(tempPathName);
      open_file(mode);
    }
    if(strcmp(cmd,"close")==0){
      int mode = atoi(pathname);
      close_file(mode);
    }
    if(strcmp(cmd, "lseek")==0){
      int fd = atoi(pathname);
      int position = atoi(tempPathName);
      printf("fd: %d\tposition: %d\n",fd,position);
      my_lseek(fd,position);
    }
    if(strcmp(cmd, "pfd")==0){
      my_pfd();
    }
    if(strcmp(cmd, "read")==0){
      read_file();
    }
    if(strcmp(cmd, "cat")==0){
      cat_file();
    }
    if(strcmp(cmd, "write")==0){
      write_file();
    }
    if(strcmp(cmd, "cp")==0){
      my_cp(tempPathName);
    }
    if(strcmp(cmd, "mv")==0){
      my_mv();
    }
  }
}

int quit()
{
  int i;
  MINODE *mip;
  for (i=0; i<NMINODE; i++){
    mip = &minode[i];
    if (mip->refCount > 0)
      iput(mip);
  }
  exit(0);
}
#include "globals.h"

//Functions
int make_dir(){
  char *parent;
  char *child;

  //System Calls To Tokenize Pathname
  char temp_pathname[64];
  strcpy(temp_pathname,pathname);
  parent = dirname(pathname);
  child = basename(temp_pathname);

  //Get INODE Number
  int pino = getino(dev,parent);
  //Get INODE Itself
  MINODE *pip = iget(dev,pino);

  if(pip->INODE.i_mode == 0x41ED){ //Is Dir
    //*********** add check to see if child already exists
    char mkdir_buf[BLKSIZE], temp[256];
    char *cp;
    DIR *dp;
    get_block(dev,pip->INODE.i_block[0],mkdir_buf);

    cp = mkdir_buf;
    dp = (DIR *)mkdir_buf;

    while(cp < mkdir_buf+1024){
      strncpy(temp,dp->name,dp->name_len);
      temp[dp->name_len]=0;
      if(strcmp(temp,child)==0){
	printf("Name Already Exists\n");
	return -1;
      }
      cp += dp->rec_len;
      dp = (DIR *)cp;
    }

    //*********** end add check
    mymkdir(pip, child);
    //Update pip
    pip->INODE.i_links_count++;
    pip->dirty = 1;
    //Touch a_time ;)
    pip->INODE.i_atime = time(0L);
    iput(pip);
  }
  else{ //Is Not DIR
    printf("Parent Is Not A Directory\n");
    return -1;
  }
}
int mymkdir(MINODE *pip, char *name){


  //Allocate An INODE AND DiskBlock For The New Directoy To Utilize
  int ino = ialloc(pip->dev); //Number For INODE
  int bno = balloc(pip->dev); //Number For BlockNumber

  //mip = get(dev,ino); To Load The INODE Into A MINODE[] (This Is So You Can Write To The INODE In Memory)
  MINODE *mip = iget(pip->dev,ino);

  //Overwrite Contents In mip->INODE To Make It A Dir
  INODE *ip = &mip->INODE;
  ip->i_mode = 0x41ED;                         //Or 040755 (DIR Type With Permissions)
  ip->i_uid = running->uid;                    //Owner uid
  ip->i_gid  = running->gid;                   //Group Id
  ip->i_size = BLKSIZE;                        //Size in bytes
  ip->i_links_count = 2;                       //Links count=2 because of . and ..
  ip->i_atime = ip->i_ctime = ip->i_mtime = time(0L);  //Set to current time
  ip->i_blocks = 2;                            // LINUX: Blocks count in 512-byte chunks
  ip->i_block[0] = bno;                        // new DIR has one data block
  for(int i = 1; i <= 14; i++){
    ip->i_block[i]=0;                          //Set i_blocks Equal To Zero
  }
  mip->dirty = 1;

  //Write The New INODE Out To Disk
  iput(mip);

  //Now Begin The Process For Creating Data Blocks For The New Dir Containing . And ..
  //Write . and .. entries into a buf[] of BLKSIZE (1024)
  char tempname[EXT2_NAME_LEN];
  char buf[BLKSIZE];
  char *cp = buf;
  DIR *dp = (DIR *)buf;

  tempname[0] = '.';
  strcpy(dp->name, tempname);
  dp->rec_len = 12;
  dp->name_len = 1; //Needs To Be 1 Byte
  dp->inode = ino;

  cp += dp->rec_len; //Increment cp
	dp = (DIR *) cp;

  tempname[1] = '.';
  strcpy(dp->name,tempname);
  dp->rec_len = BLKSIZE-12;
  dp->name_len = 2;
  findino(pip, &dp->inode);


  //puts block
  put_block(pip->dev,bno, buf);

  //Enter The Name ENTRY Into The Parent's Directory
  enter_name(pip,ino,name);
}
int enter_name(MINODE *pip, int myino, char *myname){
  char buf[BLKSIZE];
  char * cp;
  DIR * dp;
  INODE * ip = &(pip->INODE);
  int allonew = 0; //flag to see if you need to allocate new block
  int i = 0;	//allocated outside forloop to keep value of next empty block
  for(i = 0; i < 12; i++){
    if(ip->i_block[i]==0){
      allonew = 1;
      break;
    }
    get_block(pip->dev,ip->i_block[i],buf);

    //Traverse Through Till The Last Entry In Data Block
    //Get Parents ith Data Block Into A buf[]
    cp = buf;
    dp = (DIR *)buf;

    printf("Step To Last Entry In Data Block %d\n",i);
    while(cp + dp->rec_len < buf + BLKSIZE){
      //Increment
      //printf("%d\n", cp);
      cp += dp->rec_len;
      dp = (DIR *)cp;
    }

    printf("At last entry placing %s\n",myname);
    int needed_length = 4*((8+strlen(myname)+3)/4);
    int ideal_length = (4*((8+dp->name_len + 3)/4));
    int remain = dp->rec_len - ideal_length;

    if (remain >= needed_length){
      printf("There was room in last block\n");
      dp->rec_len = ideal_length;
      cp += dp->rec_len;
      //increments dp to the empty DIR structure
      dp = (DIR *)cp;
      dp->inode = myino;
      dp->rec_len = remain;
      dp->name_len = strlen(myname);
      strcpy(dp->name, myname);
      break;
    }
  }
  //END FOR LOOP


  //If You Reach Here There Is No Space In The Existing Data Blocks
  //Allocate a  new data block, Then Increase Parent's size by 1024;
  //Enter The New Entry As The First Entry In The New Data Block With rec_len=BLKSIZE
  if(allonew){//if allonew is 1 then allocate new block
    printf("There was not room in last block for creation");
    int bno = balloc(pip->dev);
    ip->i_size += BLKSIZE;
    ip->i_block[i] = bno;
    get_block(pip->dev, ip->i_block[i], buf);
    cp = buf;
    dp = (DIR *)buf;
    dp->inode = myino;
    dp->rec_len = BLKSIZE;
    dp->name_len = strlen(myname);
    strcpy(dp->name, myname);
  }
  //Write The Data Block To The Disk
  put_block(pip->dev, ip->i_block[i], buf);
}

int creat_file(){
  char *parent;
  char *child;

  //System Calls To Tokenize Pathname
  char temp_pathname[64];
  strcpy(temp_pathname,pathname);
  parent = dirname(pathname);
  child = basename(temp_pathname);

  //Get INODE Number
  int pino = getino(dev,parent);
  //Get INODE Itself
  MINODE *pip = iget(dev,pino);
  if(pip->INODE.i_mode == 0x41ED){ //Parent Is Dir
    //*********** add check to see if child already exists
    char creat_buf[BLKSIZE], temp[256];
    char *cp;
    DIR *dp;
    get_block(dev,pip->INODE.i_block[0],creat_buf);

    cp = creat_buf;
    dp = (DIR *)creat_buf;

    while(cp < creat_buf+1024){
      strncpy(temp,dp->name,dp->name_len);
      temp[dp->name_len]=0;
      if(strcmp(temp,child)==0){
	printf("Name Already Exists\n");
	return -1;
      }
      cp += dp->rec_len;
      dp = (DIR *)cp;
    }

    //*********** end add check
    my_creat(pip, child);
    //Update pip
    //Dont Increment Parent Count
    pip->dirty = 1; //Set To Dirty

    //Touch a_time
    pip->INODE.i_atime = time(0L);
    iput(pip);
  }
  else{ //Parent Is Not DIR
    printf("Parent Is Not A Directory Cannot Place File\n");
    iput(pip);
    return -1;
  }
}

int my_creat(MINODE *pip, char *name){
  //Allocate An INODE AND DiskBlock For The New Directoy To Utilize
  int ino = ialloc(dev); //Number For INODE

  //mip = get(dev,ino); To Load The INODE Into A MINODE[] (This Is So You Can Write To The INODE In Memory)
  MINODE *mip = iget(dev,ino);

  //Overwrite Contents In mip->INODE To Make It A Dir
  INODE *ip = &(mip->INODE);
  ip->i_mode = 0x81A4;                         //Or 040755 (DIR Type With Permissions)
  ip->i_uid = running->uid;                    //Owner uid
  ip->i_gid  = running->gid;                   //Group Id
  ip->i_size = 0;                        //Size in bytes
  ip->i_links_count = 1;                       //Links count=2 because of . and ..
  ip->i_atime = ip->i_ctime = ip->i_mtime = time(0L);  //Set to current time
  ip->i_blocks = 0; //Can You Do This?                            // LINUX: Blocks count in 512-byte chunks
  //Put In THe Name In Parent Inode Pointer
  enter_name(pip, ino, name);


  mip->dirty = 1;
  //Write The New INODE Out To Disk
  iput(mip);
}
//This file will enclose open,close,lseek.

#include "globals.h"

int open_file(int mode){
  //1) Ask For A Pathname And Mode To Open
  //2) Get pathnames inumber
  //3) Get Its MINODE Pointer
  int ino = getino(dev,pathname);
  if(ino){
    MINODE *mip = iget(dev,ino);
    int i=0;
    int j=0;
    //4) Check Inodes i_mode to verify Regular File And Permissions OK
    if(mip->INODE.i_mode != 0x41ED){
      printf("Is File\n");
      for(i = 0; i < 10; i++){
        printf("Iteration: %d\n\n",i);

        if(running->fd[i] == 0){ //There is NO File
        	printf("NO FILE\n");
        	for(j = 0; j < 10; j++){
        	  printf("Sub Iteration: %d\n",j);
        	  if(running->fd[j] == 0){
        	    OFT * oftp = (OFT *)malloc(sizeof(OFT));
        	    oftp->mode = mode;
        	    oftp->refCount = 1;
        	    mip->INODE.i_atime = time(0L);
        	    oftp->mptr = mip;
        	    switch(mode){
        	    case 0:
        	      printf("Set Mode 0\n");
        	      oftp->offset = 0;
        	      break;
        	    case 1:
        	      printf("Set Mode 1\n");
        	      truncate(mip);
        	      mip->INODE.i_mtime = time(0L);
        	      oftp->offset = 0;
        	      break;
        	    case 2:
        	      printf("Set Mode 2\n");
        	      mip->INODE.i_mtime = time(0L);
        	      oftp->offset = 0;
        	      break;
        	    case 3:
        	      printf("Set Mode 3\n");
        	      mip->INODE.i_mtime = time(0L);
        	      oftp->offset = mip->INODE.i_size;
        	      break;
        	    default:
        	      printf("Invalid Mode\n");
        	      return -1;
        	    }
        	    //Set Running Equal To OFTP and Return The i Value
        	    running->fd[j] = oftp;
        	    return j;
        	    }
        	}
              }
              else{ //There Is File Check
        	printf("Ran into File, Check\n");
        	if(running->fd[i]->mptr->ino == ino){
        	  if(running->fd[i]->mode == 1){ //Write Mode
        	    printf("Open For Incorrect Mode\n");
        	    return -1;
        	  }
        	  else if(running->fd[i]->mode == 2){ //Read Write Mode
        	    printf("Open For Incorrect Mode\n");
        	    return -1;
        	  }
        	  else if(running->fd[i]->mode == 3){ //Append Mode
        	    printf("Open For Incorrect Mode\n");
        	    return -1;
        	  }
        	  else if(running->fd[i]->mode == 0 && mode != 0){
        	    printf("File Is Open For Read\n");
        	    return -1;
        	  }
        	  else{ //Must Be Read Mode If This Is Reached
        	    for(j = 0; j < 10; j++){
        	      if(running->fd[j] == 0){
        		OFT * oftp = (OFT *)malloc(sizeof(OFT));
        		oftp->mode = mode;
        		oftp->refCount = 1;
        		mip->INODE.i_atime = time(0L);
        		oftp->mptr = mip;
        		switch(mode){
        		case 0:
        		  printf("Case 0\n");
        		  oftp->offset = 0;
        		  break;
        		case 1:
        		  printf("Case 1\n");
        		  truncate(mip);
        		  oftp->offset = 0;
        		  break;
        		case 2:
        		  printf("Case 2\n");
        		  oftp->offset = 0;
        		  break;
        		case 3:
        		  printf("Case 3\n");
        		  oftp->offset = mip->INODE.i_size;
        		  break;
        		default:
        		  printf("Invalid Mode\n");
        		  return -1;
        		}
        		//Set Running Equal To OFTP and Return The i Value
        		running->fd[j] = oftp;
        		return j;
        	      }
        	    }
        	  }
        	}
        }
      }
    }
    iput(mip);
  }
  else{
    return -1;
  }
}

int my_truncate(MINODE *mip){
  //Direct
  int i = 0;
  for(i = 0; i < 12; i++){
    if(mip->INODE.i_block[i] != 0){
      bdealloc(dev,mip->INODE.i_block[i]);
    }
  }
  //Indirect
  int j = 0;
  int ino;
  MINODE *temp_mip;
  int buf[256];
  int indirect_buf[256];
  get_block(dev,mip->INODE.i_block[12],buf);
  for(j = 0; j < 256; j++){
    if(buf[j] != 0){
	bdealloc(dev,buf);
    }
  }
  //Double Indirect
  get_block(dev,mip->INODE.i_block[13],buf);
  for(int l = 0; l < 256; l++){
    get_block(dev,buf[l],indirect_buf);
    for(int m = 0; m < 256; m++){
      if(indirect_buf[m] != 0){
	bdealloc(dev,indirect_buf[m]);
      }
    }
  }


  mip->INODE.i_size = 0;
  mip->dirty = 1;
  iput(mip);
}

int close_file(int fd){
  if(fd > 9 || fd < 0){
    return -1;
  }
  if(running->fd[fd] != 0){ //Not Null, Pointing At Something
    OFT * oftp = running->fd[fd];
    oftp = running->fd[fd];
    running->fd[fd] = 0;
    oftp->refCount--;
    if (oftp->refCount > 0){
      return 0;
    }

    MINODE *mip = oftp->mptr;
    mip->dirty=1;
    iput(mip);
    free(oftp);

    return 0;
  }
}

int my_lseek(int fd, int position){
  //From fd find the OFT entry
  if(running->fd[fd] == 0){
    printf("Didnt Work\n");
    return -1;
  }
  else{//File Isnt NULL
    int original_position = 0;
    //Must check to make sure it doesnt overstep the position.

    if(position < 0){ //Under Start Of File
      printf("Cannot be less that offset 0\n");
      original_position=running->fd[fd]->offset; //Grab original position to return
      running->fd[fd]->offset = 0; //reset new position to zero
      printf("Original Position: %d\n",original_position);
      return original_position; //return original position
    }
    else if(running->fd[fd]->mptr->INODE.i_size < position){ //Passed End Of File
      printf("Cannot Be More than size\n");
      original_position=running->fd[fd]->offset; //Grab original position to return
      running->fd[fd]->offset = (running->fd[fd]->mptr->INODE.i_size); //reset new position to end of file
      printf("Original Position: %d\n",original_position);
      return original_position; //return original position
    }
    else{ //The good position
      printf("This soup is just right\n");
      original_position=running->fd[fd]->offset; //Grab original position to return
      running->fd[fd]->offset = position; //reset new position
      printf("Original Position: %d\n",original_position);
      return original_position; //return original position
    }
  }
 }

int my_pfd(){
  printf(" fd   mode  offset   INODE\n");
  printf("---- ----- -------- -------\n");
  for(int i = 0; i < 10; i++){
    if(running->fd[i] == 0){
    }
    else{
      printf("  %d      %d     %d     [dev,%d]\n",i,running->fd[i]->mode,running->fd[i]->offset,running->fd[i]->mptr->ino);
    }
  }

}
#include "globals.h"

int read_file(){
  //pathname contains the fd number and nbytes to read
  int fd, nbytes;
  fd = atoi(pathname);
  nbytes = atoi(tempPathName);
  char buf[(256+12+256*256)*BLKSIZE];//buf large enough to hold the entire file
  if(running->fd[fd] != 0){
    if(running->fd[fd]->mode == 0 || running->fd[fd]->mode == 2){
      return my_read(fd,buf,nbytes);
    }
    else{
      printf("ERROR: File desciptor not open to READ\n");
    }
  }
  else{
    printf("ERROR: File desciptor not open\n");
  }
  return -1;
}

int my_read(int fd, char * buf, int nbytes){
  MINODE *mip, *mip2;
  mip = running->cwd;
  int count = 0, blk;
  if(nbytes > running->fd[fd]->mptr->INODE.i_size){
    nbytes = running->fd[fd]->mptr->INODE.i_size;//if nbytes is more than size set it to size
  }
  int available = running->fd[fd]->mptr->INODE.i_size - running->fd[fd]->offset;
  char  *cp = buf, readbuf[BLKSIZE];
  mip2 = running->fd[fd]->mptr;

  while(nbytes && available){
    //maps logic block to physical block
    int lbk = running->fd[fd]->offset / BLKSIZE;
    int startbyte = running->fd[fd]->offset % BLKSIZE;

    if(lbk < 12){
      blk = mip2->INODE.i_block[lbk];
    }
    else if(lbk >= 12 && lbk < 256 + 12){
      int indirect[256];
      get_block(mip2->dev,mip2->INODE.i_block[12],indirect);
      blk = indirect[lbk-12];
    }
    else{
      int dbl_indirect[256];
      get_block(mip2->dev,mip2->INODE.i_block[13],dbl_indirect);
      for(int j = 1; j<257; j++){
        if(lbk >= 256*j+12 && lbk < 256*(j+1) + 12)
        {
          int block_storage[256];
          get_block(mip2->dev,dbl_indirect[j-1],block_storage);
          blk = block_storage[lbk-(256*j+12)];
          break;
        }
      }
    }
    if(blk == 0){
      return count;
    }
    //end mapping

    get_block(mip->dev, blk, readbuf);

    char *store = readbuf + startbyte;
    int remain = BLKSIZE - startbyte;
    while(remain > 0){
      if(nbytes-BLKSIZE > 0){
        //printf("BLKSIZE to read\n");
        strncpy(buf, store, BLKSIZE);
        count += BLKSIZE;
        nbytes -= BLKSIZE;
        available -= BLKSIZE;
        remain -= BLKSIZE;
        running->fd[fd]->offset += BLKSIZE;

        if(nbytes <= 0){
          break;
        }
      }
      else{
        //printf("less than BLKSIZE to read\n");
        strncpy(buf, store, nbytes);
        count += nbytes;
        available -= nbytes;
        remain -= nbytes;
        running->fd[fd]->offset += nbytes;
        nbytes -= nbytes;
        if(nbytes <= 0){
          break;
        }
      }
    }
  }
  return count;
}

int cat_file(){
  char buf[BLKSIZE];
  int n, i = 0;

  int fd = open_file(0);
  if(fd > -1){
    while( n = my_read(fd, buf, BLKSIZE)){
      for(i=0;i<n;i++){
        if(buf[i] == '\\'){
          if(buf[i+1] == 'n'){//if new line print new line
            putchar('\n');
            i++;
          }
        }else{
          putchar(buf[i]);
        }
      }
    }
    printf("\n");//print new line
    close_file(fd);
  }
  else{
    printf("ERROR: couldn't open file to read\n");
  }
}
#include "globals.h"

int my_rm(){
  MINODE *mip, *pip;
  INODE *ip;
  char buf[BLKSIZE];

  char *Child;
  char *Parent;
  char temp[64];
  char temp2[64];
  strcpy(temp,pathname);
  Parent = dirname(temp);
  strcpy(temp2,pathname);
  Child = basename(temp2);

  int child_ino = getino(dev,pathname);
  if(child_ino == 0){
    printf("Passed Path Cannot Be Found, Cannot Remove\n");
    return -1;
  }
  mip = iget(dev,child_ino);

  int parent_ino = getino(dev,Parent);
  pip = iget(dev,parent_ino);

  ip=&(mip->INODE);
  printf("ip->i_uid: %d\trunning->uid: %d\n",ip->i_uid, running->uid);

  if(ip->i_uid == running->uid || running->uid == 0){
    printf("User Can Remove Object\n");
    if(ip->i_mode != 0x41ED){
      printf("User Can Remove File\n");

      truncate(mip);
      printf("Deallocate inode\n");
      idealloc(dev, mip->ino);
      mip->dirty = 1;


      printf("Removing %s from parent's list\n", Child);
      rm_child(pip, Child);
      pip->dirty = 1;
      pip->INODE.i_links_count--;
      pip->INODE.i_atime = pip->INODE.i_mtime = time(0L);

    }
  }
  iput(mip);
  iput(pip);
}
#include "globals.h"

//This File Will House rmdir And All Related Functions.

int rmdir(){
  MINODE *mip, *pip;
  INODE *ip;
  char buf[BLKSIZE];
  int empty=1;

  int ino = getino(dev, pathname);//currently assumes dev
  if(ino == 0){
    printf("Path not found can't remove\n");
    return -1;
  }
  mip = iget(dev, ino);

  char myname[256];

  ip = &(mip->INODE);
  printf("%d %d\n", ip->i_uid, running->uid);
  if(ip->i_uid == running->uid ||  running->uid == 0){//checks to see if user owns dir or if user is super user getuid() is a systemcall
    printf("User can rmdir\n");
    if(ip->i_mode == 0x41ED){
      printf("Refcount is %d\n",mip->refCount);
      if( mip->refCount == 1 ){
        if( ip->i_links_count == 2){//checks if not a dir or busy or not empty
          printf("Might be empty link count is %d\n", ip->i_links_count);
        	printf("Checking if truly empty\n");
        	char *cp;
        	get_block(mip->dev, ip->i_block[0], buf);

        	cp = buf;
        	cp += 12;//points to ..
        	dp = (DIR *)cp;

        	if(dp->rec_len == 12){//dir contains files
        	  empty = 0;
        	}
        	else{
        	  empty = 1;//flag to check empty
        	}
          if(!empty){
            printf("ERROR: Dir not empty\n");
            iput(mip);
            return -1;
          }
        }
        else{
          printf("ERROR: Dir not empty\n");
          iput(mip);
          return -1;
        }
      }
      else{
        printf("ERROR: Dir is busy\n");
        iput(mip);
        return -1;
      }
    }
    else
    {
      printf("ERROR: Not a dir\n");
      iput(mip);
      return -1;
    }
    pip = iget(mip->dev, dp->inode);//dp already points to ..
    getmyname(pip, mip->ino, myname);
    truncate(mip);
    printf("Deallocate inode\n");
    idealloc(mip->dev, mip->ino);
    mip->dirty = 1;
    iput(mip);

    printf("Removing %s from parent's list\n", myname);
    rm_child(pip, myname);
    pip->dirty = 1;
    pip->INODE.i_links_count--;
    pip->INODE.i_atime = pip->INODE.i_mtime = time(0L);
    iput(pip);
  }
}

int rm_child(MINODE * parent, char *name){
  INODE *ip = &(parent->INODE);
  char buf[BLKSIZE], myname[256];
  char *cp, c, *cp2;
  DIR *dpnext, *dpprev;//next dp
  int i = 0, found = 0, location = 0, size = 0;
  for(i = 0; i<12; i++){//loop to find dp containing name
    get_block(parent->dev, ip->i_block[i], buf);
    cp = cp2 = buf;
    dp = (DIR *)cp;
    cp2 += dp->rec_len;
    dpnext = (DIR *)cp2;

    while(cp < buf + BLKSIZE){
      //printf("%d\n", dp->inode);//inode of current thing
      c = dp->name[dp->name_len];
      dp->name[dp->name_len] = 0;
      //printf("%s , %d compare to %s\n",dp->name, dp->inode, name);
      if(strcmp(dp->name,name) == 0){
        printf("FOUND IT\n");
	       found = 1;
      }
      dp->name[dp->name_len] = c;
      printf("%d\n", dp->inode);
      if(found){
	       break;
      }
      dpprev = dp;
      cp += dp->rec_len;
      location += dp->rec_len;
      dp = dpnext;
      cp2 += dpnext->rec_len;

      dpnext = (DIR *)cp2;
    }
    if(found){
      break;
    }
  }
  //printf("%s found in block %d\n",name, i);
  getmyname(parent, dp->inode, myname);
  //printf("%s location %d, dp->rec_len %d\n", myname, location, dp->rec_len);
  size = dp->rec_len;

  if(dp->rec_len == BLKSIZE){//beginning of block
    printf("1\n");
    bdealloc(parent->dev, ip->i_block[i]);
    while(ip->i_block[i+1] != 0){//shifts existing blocks over
      ip->i_block[i] = ip->i_block[i+1];
    }
    ip->i_block[i] = ip->i_block[i+1];
  }
  else if(location + dp->rec_len == BLKSIZE){//end of block
    printf("2\n");
    dpprev->rec_len += dp->rec_len;
    dp->inode = 0;
    dp->name_len = 0;
    dp->rec_len = 0;
    for(int j = 0; j < dp->name_len; j++){
      dp->name[j] = 0;
    }
  }
  else {//somewhere in the middle
    //printf("%d size of removed record\n", size);
    //printf("3\n");
    while(size + cp2 + dp->rec_len < buf + BLKSIZE){//shifts the other dp's to the left so there are no gaps
      cp += dp->rec_len;
      c = dpnext->name[dpnext->name_len];
      dpnext->name[dpnext->name_len] = 0;
      printf("Shifting %s to replace  %d \n", dpnext->name, dp->inode);
      dpnext->name[dpnext->name_len] = c;
      dp->inode = dpnext->inode;
      dp->rec_len = dpnext->rec_len;
      dp->name_len = dpnext->name_len;
      strncpy(dp->name, dpnext->name, dpnext->name_len);

      dpprev = dp;
      cp2 += dpnext->rec_len;
      dp = dpnext;
      dpnext = (DIR *)cp2;
    }

    dpprev->rec_len += size;
  }
  put_block(parent->dev,ip->i_block[i],buf);
  parent->dirty = 1;

}
#include "globals.h"

char buf[BLKSIZE];
MINODE *mip;
INODE *ip;


int stat_file(int ino,char temp[]){
  mip = iget(dev, ino);
  ip = &(mip->INODE);

  //Set Up For Printing permissions
  char *permission = "rwxrwxrwx";
  printf("Name:        %s\n",temp);
  printf("Permissions: ");
  for(int i = 0; i < 9; i++){ //{arse Through permissions
    if(ip->i_mode & (1 << (strlen(permission)-1-i))){
      putchar(permission[i]);
    }
    else{
      putchar('-');
    }
  }
  printf("\ni_mode:      %07o\n",ip->i_mode);
  printf("i_uid:       %d\n",ip->i_uid);
  printf("i_gid:       %d\n",ip->i_gid);
  printf("i_atime:     %ld\n",ip->i_atime);
  printf("i_mtime:     %lu\n",ip->i_mtime);
  printf("i_ctime:     %d\n",ip->i_ctime);
  printf("Link Count:  %d\n",ip->i_links_count);
  printf("device:      %d\n",dev);
  printf("size:        %d\n",ip->i_size);  
}

int my_stat(int ino){
  //Get MIP Based Off Of Passed ino (No Need For Parent, Doesn't Take Path)
  mip = iget(dev, ino);
  ip = &(mip->INODE);

  //Load In INODEs Data Block[0] Into stat_buf
  char stat_buf[BLKSIZE], stat_temp[256];
  char *cp;
  get_block(dev, ip->i_block[0], stat_buf);

  //Set Up cp and dp
  cp = stat_buf;
  dp = (DIR *)stat_buf;

  while(cp < stat_buf+1024){//Parse Through stat_buf For pathname(name)
    strncpy(stat_temp, dp->name, dp->name_len);
    stat_temp[dp->name_len] = 0;
    if(strcmp(stat_temp,pathname)==0){ //If Hit
      stat_file(dp->inode,stat_temp); //Used For Printing (Pass ino,name)
    }
    //Increment
    cp += dp->rec_len;
    dp = (DIR *)cp;
  }
}
#include "globals.h"

int my_symlink(char *oldname, char *newname){
  int inumber = getino(dev, oldname);
  if(inumber){//if inumber not 0 then oldname exists
    strcpy(pathname,newname);
    creat_file();
    int ino2 = getino(dev, newname);
    MINODE *mip = iget(dev, ino2);
    mip->INODE.i_mode = 0120000;
    char buf[BLKSIZE];
    int blkno = balloc(dev);
    mip->INODE.i_block[0] = blkno;
    get_block(dev,blkno,buf);
    strcpy(buf,oldname);
    put_block(dev,blkno,buf);
    mip->INODE.i_size = strlen(oldname)+1;
    mip->dirty = 1;
    iput(mip);
  }
}

char * my_readlink(){
  int ino = getino(dev, pathname);
  MINODE * mip = iget(dev, ino);
  char buf[BLKSIZE];
  int blk = mip->INODE.i_block[0];
  get_block(dev,blk,buf);
  return buf;
}
#include "globals.h"

int my_touch(){

  int ino = getino(dev,pathname);
  if(ino == 0){ //No File Exists
    creat_file(); //Call FileName
  }
  else{ //File Exists Touch It
    MINODE *mip = iget(dev,ino);
    mip->INODE.i_atime = mip->INODE.i_mtime = time(0L); //Touch It
    mip->dirty=1; //Its Dirty From Touching
    iput(mip); //Put it in its place
  }
}
/*********** util.c file ****************/
#include "globals.h"

int get_block(int dev, int blk, char *buf)
{
   lseek(dev, (long)blk*BLKSIZE, 0);
   read(dev, buf, BLKSIZE);
}
int put_block(int dev, int blk, char *buf)
{
   lseek(dev, (long)blk*BLKSIZE, 0);
   write(dev, buf, BLKSIZE);
}

int search(INODE *ip, char *name){
  char *cp2;
  char dirname[256], buf2[BLKSIZE];
  int i = 0;


  while(ip->i_block[i] > 0){ // assume: DIRs have at most 12 direct blocks
    printf("i_block[%d] = %d\n", i, ip->i_block[i]);

    get_block(dev, ip->i_block[i], buf2);
    cp2 = buf2;
    dp = (DIR *)buf2;

    while(cp2 < buf2+BLKSIZE){
      strncpy(dirname, dp->name, dp->name_len);
      dirname[dp->name_len] = 0;
      printf("%4d %4d %4d   %s\n", dp->inode, dp->rec_len, dp->name_len,dirname);
      printf("dirname = %s; name = %s\n",dirname,name);
      if(strcmp(name,dirname)==0){//found
	return dp->inode;
      }
      cp2 += dp->rec_len;
      dp = (DIR *)cp2;
    }
    i++;
  }
  return 0;//not found
}


int getmyname(MINODE *parent, int myino, char *myname) 
{
 int i;
 char buf[BLKSIZE], temp[256], *cp;
 DIR    *dp;
 MINODE *mip = parent;

 //**********  search for a file name ***************
 for (i=0; i<12; i++){ // search direct blocks only
     if (mip->INODE.i_block[i] == 0)
           return -1;

     get_block(mip->dev, mip->INODE.i_block[i], buf);
     dp = (DIR *)buf;
     cp = buf;

     while (cp < buf + BLKSIZE){
       strncpy(temp, dp->name, dp->name_len);
       temp[dp->name_len] = 0;
       //printf("%s  ", temp);

       if (dp->inode == myino){
           strncpy(myname, dp->name, dp->name_len);
           myname[dp->name_len] = 0;
           return 0;
       }
       cp += dp->rec_len;
       dp = (DIR *)cp;
     }
 }
 return -1;
}


int findino(MINODE *mip, int *myino)
{
  char buf[BLKSIZE], *cp;
  DIR *dp;

  get_block(mip->dev, mip->INODE.i_block[0], buf);
  cp = buf;
  dp = (DIR *)buf;
  *myino = dp->inode;
  cp += dp->rec_len;
  dp = (DIR *)cp;
  return dp->inode;
}
#include "globals.h"

int write_file(){
  int fd, nbytes;
  fd = atoi(pathname);
  nbytes = strlen(tempPathName);
  printf("%d is bytes to be written\n",nbytes);
  if(running->fd[fd] != 0){
    if(running->fd[fd]->mode == 1 || running->fd[fd]->mode == 2 || running->fd[fd]->mode == 3){
      return my_write(fd,tempPathName,nbytes);
    }
    else{
      printf("ERROR: File desciptor not open to Write\n");
    }
  }
  else{
    printf("ERROR: File desciptor not open\n");
  }
  return -1;
}

int my_write(int fd, char buf[], int nbytes){
  int lbk, blk, startbyte, tot = 0;
  char writebuf[BLKSIZE];
  MINODE *mip = running->fd[fd]->mptr;
  INODE *ip = &(mip->INODE);
  while(nbytes > 0){
      lbk = running->fd[fd]->offset / BLKSIZE;
      startbyte = running->fd[fd]->offset % BLKSIZE;

      if(lbk < 12){
        if(ip->i_block[lbk] == 0){
          int nblk = balloc(mip->dev);
          if(!nblk){
            printf("ERROR: no more free blocks\n");
            return -1;
          }
          ip->i_block[lbk] = nblk;
        }
        blk = ip->i_block[lbk];
      }
      else if (lbk >= 12 && lbk < 256+12){//indirect
        int indirect[256];
        if(ip->i_block[12] == 0){
          int nblk = balloc(mip->dev);
          if(!nblk){
            printf("ERROR: no more free blocks\n");
            return -1;
          }
          ip->i_block[12] = nblk;
        }
        get_block(mip->dev,ip->i_block[12],indirect);
        blk = indirect[lbk-12];
        if(blk == 0){
          int nblk = balloc(mip->dev);
          if(!nblk){
            printf("ERROR: no more free blocks\n");
            return -1;
          }
          indirect[lbk-12] = nblk;
          blk = indirect[lbk-12];
        }

      }
      else{//double indirect
        int dbl_indirect[256];
        if(ip->i_block[13] == 0){
          int nblk = balloc(mip->dev);
          if(!nblk){
            printf("ERROR: no more free blocks\n");
            return -1;
          }
          ip->i_block[13] = nblk;
        }
        get_block(mip->dev,mip->INODE.i_block[13],dbl_indirect);
        for(int j = 1; j<257; j++){
          if(dbl_indirect[j-1] == 0){
            int blocky = balloc(mip->dev);
            if(!blocky){
              printf("ERROR: no more free blocks\n");
              return -1;
            }
            dbl_indirect[j-1] = blocky;
          }
          if(lbk >= 256*j+12 && lbk < 256*(j+1) + 12)
          {
            int block_storage[256];
            get_block(mip->dev,dbl_indirect[j-1],block_storage);
            blk = block_storage[lbk-(256*j+12)];
            if (blk == 0){
              int nblk = balloc(mip->dev);
              if(!nblk){
                printf("ERROR: no more free blocks\n");
                return -1;
              }
              block_storage[lbk-(256*j+12)] = nblk;
            }
            break;
          }
        }
      }

      printf("Block was gotten\n");
      get_block(mip->dev, blk, writebuf);
      char *cp = writebuf + startbyte;
      int remain = BLKSIZE - startbyte;

      if(nbytes >= BLKSIZE){
        printf("BLKSIZE to write\n");
        running->fd[fd]->offset += BLKSIZE;
        if(running->fd[fd]->offset > ip->i_size){
          ip->i_size += BLKSIZE;
        }
        strncpy(cp, buf, remain);
        tot += BLKSIZE;
        nbytes -= BLKSIZE;
        remain -= BLKSIZE;


        if(nbytes <= 0){
          break;
        }
      }
      else{
        printf("less than BLKSIZE to write\n");
        running->fd[fd]->offset += nbytes;
        if(running->fd[fd]->offset > ip->i_size){
          ip->i_size += nbytes;
        }
        strncpy(cp, buf, nbytes);
        tot += nbytes;
        nbytes -= nbytes;
        remain -= nbytes;


      }

      put_block(mip->dev, blk, writebuf);
  }
  mip->dirty = 1;
  printf("Wrote %d characters to fd=%d\n",tot,fd);
  return tot;
}

int my_cp(char *dest){
  int n = 0;
  char buf[BLKSIZE];
  int fd = open_file(0);//opens pathname for read
  strcpy(pathname, dest);//sets destination for Pathname
  //printf("pathname = %s\n", pathname);
  int gd = open_file(1);
  //printf("fd is %d, gd is %d\n",fd, gd);
  if(fd == -1 && gd == -1){//both failed
    printf("ERROR: copy failed both\n");
    return -1;
  }
  else if(fd == -1){//only fd failed
    close_file(gd);
    printf("ERROR: copy failed\n");
    return -1;
  }
  else if(gd == -1){//only gd failed
    strcpy(pathname, dest);
    //printf("pathname = %s\n", pathname);
    creat_file();
    gd = open_file(1);
    int tot = 0;
    while( n = my_read(fd,buf,BLKSIZE)){
      tot += my_write(gd,buf,n);
    }
    printf("%d is n\n",n);
    close_file(fd);
    close_file(gd);
    printf("Total bytes copied %d\n",tot);
    return tot;
  }
  else{//both succeeded
    printf("Both fd opened\n");
    int tot = 0;
    while( n = my_read(fd,buf,BLKSIZE)){
      tot += my_write(gd,buf,n);
    }
    close_file(fd);
    close_file(gd);
    printf("Total bytes copied %d\n",tot);
    return tot;
  }
}

int my_mv(){
  int ino = getino(dev,pathname);
  if(ino){
    if(my_link(pathname,tempPathName)){
      my_unlink(pathname);
    }
    else{
      printf("ERROR: move failed\n");
      return -1;
    }
  }
}
